\documentclass{report}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{mathtools}
\usepackage{amssymb}
\usepackage{hyperref}
\usepackage{float}
\usepackage{amsthm}
\usepackage{listings}
\usepackage{geometry}
\usepackage{setspace}
\usepackage{graphicx}
\usepackage{fancyhdr}
\usepackage{subcaption}
\usepackage{cleveref}

\usepackage{color}

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

\lstset{ 
  backgroundcolor=\color{white},   % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}; should come as last argument
  basicstyle=\footnotesize,        % the size of the fonts that are used for the code
  breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
  breaklines=true,                 % sets automatic line breaking
  commentstyle=\color{mygreen},    % comment style  
  firstnumber=0, 
  numbers=left,               
  frame=single,
  keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
  language=C,                      % the language of the code                  
  numbersep=5pt,                   % how far the line-numbers are from the code
  numberstyle=\tiny\color{mygray}, % the style that is used for the line-numbers
  rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
  showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
  showstringspaces=false,          % underline spaces within strings only
  showtabs=false,                  % show tabs within strings adding particular underscores
  stepnumber=2,                    % the step between two line-numbers. If it's 1, each line will be numbered
  stringstyle=\color{mymauve},     % string literal style
  tabsize=2,	                   % sets default tabsize to 2 spaces
  title=\lstname                   % show the filename of files included with \lstinputlisting; also try caption instead of title
}

\begin{document}
\subsection{Implémentation de l'algorithme de Gauss en passant par le système d'équations linéaires}
\subsubsection{Code source}
Voici le code source de mon implémentation de l'algorithme de Gauss sans utiliser la matrice augmentée, c'est-à-dire en travaillant directement avec le système d'équations linéaires Ax=B.\\
\begin{lstlisting}[language=C,inputencoding=utf8]
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

/*
*CREATE A 2D FLOAT MATRIX
*/

float** createMatrix(int row, int column){
	float **mat=NULL;
	mat=malloc(row* sizeof(int*));
	if(mat==NULL){return NULL;}
	for (int i=0; i<row; i++){
		mat[i]=malloc(column* sizeof(int));
		if(mat[i]==NULL){
			for(int j=0; j<i; j++){
				free(mat[j]);
				return NULL;
			}
		}
	}
	return mat;
}

/*
*PRINT A 2D FLOAT MATRIX
*/

void printMatrix(float **mat, int row, int column){
	for (int i=0; i<row; i++){
    		for(int j=0; j<column; j++){
         		printf("%f   ", mat[i][j]);
    		}
    		printf("\n");
	}
}

/*
*FREE A 2D FLOAT MATRIX
*/

void freeMatrix(float **mat, int row){
	for(int i=0; i<row;i++){
		free(mat[i]);
	}
	free(mat);
}

/*
*COMPLETE A 2D FLOAT MATRIX FROM USER INPUT
*/

void completeMatrix(float **mat, int row, int column){
	for (int i=0; i<row; i++){
    		for(int j=0; j<column; j++){
    			printf("Coefficient at M_%d,%d:   ", i+1, j+1);
         		scanf("%f", &mat[i][j]);
    		}
	}
}

/*
*GENERATE A COLUMN VECTOR "B" FROM A 2D FLOAT MATRIX "A"
*/

void generateB(float **matA, float **matB, int row, int column){
	for(int i=0; i<row; i++){
		float sum=0;
		for(int j=0; j<column; j++){
			sum+=matA[i][j];
		}
		matB[i][0]=sum;
    	}
}

/*
*PERFORM GAUSSIAN ELIMINATION ON A Ax=B MATRIX SYSTEM OF LINEAR EQUATIONS
*/

void gauss(float** matA, float** matb, int size){
	for(int k=0; k<size-1; k++){
		for(int i=k+1; i<size; i++){
			float alpha=matA[i][k]/matA[k][k];
			for(int j=k; j<size; j++){
				matA[i][j]=matA[i][j]-alpha*matA[k][j];
			}
			matb[i][0]=matb[i][0]-alpha*matb[k][0];
		}
	}
}

/*
*SOLVE A MATRIX SYSTEM OF LINEAR EQUATIONS USING BACKWARD SUBSTITUTION
*/
void resolution(float** matA, float** matb, float** matx, int size){
	matx[size-1][0]=matb[size-1][0]/matA[size-1][size-1];
	for (int i=size-2; i>=0; i--){
		float sum=0;
		for(int j=i+1; j<size; j++){
			sum+=matA[i][j]*matx[j][0];
		}
		matx[i][0]=(1/matA[i][i])*(matb[i][0]-sum);
	}
}

int main(){

	//A Matrix
	int rowA=3;
	int columnA=3;
	float** Amatrix=createMatrix(rowA, columnA);
	completeMatrix(Amatrix, rowA, columnA);
	puts("\n		A Matrix \n");
	printMatrix(Amatrix, rowA, columnA);
	
	//B Matrix
	float** Bmatrix=createMatrix(rowA, 1);
	generateB(Amatrix, Bmatrix, rowA, columnA);
	puts("\n		B Matrix \n");
	printMatrix(Bmatrix, rowA, 1);
	
	//Matrix Triangularization
	puts("\n		Triangularization \n");
	gauss(Amatrix, Bmatrix, rowA);
	puts("\n		A Matrix \n");
	printMatrix(Amatrix, rowA, columnA);
	puts("\n		B Matrix \n");
	printMatrix(Bmatrix, rowA, 1);
	
	//Solve the system
	float** Xmatrix=createMatrix(rowA, 1);
	puts("\n		Solving \n");
	resolution(Amatrix, Bmatrix, Xmatrix, rowA);
	puts("\n		Solution Vector x \n");
	printMatrix(Xmatrix, rowA, 1);
	
	//Free
	freeMatrix(Amatrix, rowA);
	freeMatrix(Bmatrix, rowA);
	freeMatrix(Xmatrix, rowA);
	return 0;
}
\end{lstlisting}

\subsubsection{Commentaires du code}
\subsubsection{Fonctions usuelles de manipulation de matrices}\label{fonctusu}
Ce code implémente diverses fonctions pour travailler avec des matrices à coefficients en nombre flottants.\\
\begin{itemize}
\item La fonction \textit{\textbf{createMatrix}} alloue dynamiquement de la mémoire pour créer une matrice de nombres flottants avec un nombre spécifié de lignes et de colonnes.
\item La fonction \textit{\textbf{printMatrix}} affiche les éléments d'une matrice de nombres flottants.
\item La fonction \textit{\textbf{freeMatrix}} libère la mémoire allouée pour une matrice de nombres flottants.
\item La fonction \textit{\textbf{completeMatrix}} permet à l'utilisateur de saisir des valeurs pour remplir les éléments d'une matrice de nombres flottants.
\item La fonction \textit{\textbf{generateB}} génère un vecteur colonne $B$ en fonction de la somme des éléments de chaque ligne de la matrice $A$.
\end{itemize}

\subsubsection{Fonctions résolvant notre système linéaire $Ax=B$ à l'aide de l'algorithme de Gauss}
Dans le cadre de notre résolution de systèmes d'équations linéaires, deux fonctions jouent des rôles clefs dans ce code : la fonction \textit{\textbf{gauss}} et la fonction \textit{\textbf{resolution}}.\\

\begin{itemize}
\item La fonction \textit{\textbf{gauss}} joue un rôle important dans la préparation de la résolution de notre système d'équations linéaires. En effectuant l'élimination de Gauss sur la matrice $A$, elle transforme cette matrice en une forme triangulaire supérieure. Cela signifie que les éléments sous la diagonale principale de la matrice deviennent tous des zéros, simplifiant ainsi la résolution du système. De plus, la fonction met également à jour la matrice $B$ en conséquence, garantissant que notre système $Ax=B$ reste équilibré.\\

\item La fonction \textit{\textbf{resolution}}, quant à elle, prend en charge la résolution effective du système linéaire une fois que la matrice $A$ a été triangulée par la fonction \textbf{gauss}. Elle utilise la méthode de substitution pour calculer la solution et stocke le résultat dans le vecteur $X$. Cette étape finale permet d'obtenir les valeurs des variables inconnues du système, fournissant ainsi la solution recherchée pour le problème initial.\\
\end{itemize}


En combinant ces deux fonctions avec celles citées dans la sous-section \ref{fonctusu}, le code réalise un processus complet de résolution de systèmes d'équations linéaires de manière efficace et précise.\\
\subsubsection{Exécution du code sur quelques matrices}
\end{document}      